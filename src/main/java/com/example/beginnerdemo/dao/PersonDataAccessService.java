package com.example.beginnerdemo.dao;

import com.example.beginnerdemo.model.Person;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository("postgres")
public class PersonDataAccessService implements PersonDao {

    // SQL query operations made easier using this class.
    // It accepts SQL string and arguments depending on the operation you want to execute.
    private final JdbcTemplate jdbcTemplate;

    @Autowired
    public PersonDataAccessService(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }


    @Override
    public int insertPerson(UUID id, Person person) {
        // ID value is generated by invoking the Postgres extension-function 'uuid_generate_v4'
        // It will automatically create UUID while executing insert operation
        // If the error occurs, it might because you have not attached the specific extension for UUID of postgres.
        // To solve it, simply create the EXTENSION, at postgres environment:
        // CREATE EXTENSION "uuid-ossp";
        // SELECT uuid_generate_v4();
        // Output should be something like this:
        //        uuid_generate_v4
        //--------------------------------------
        //          4a1d0d24-a590-40e4-9e9c-510c9d8347d6
        String sql = "INSERT INTO person (id, name) VALUES (uuid_generate_v4(), ?)";
        return  jdbcTemplate.update(sql, person.getName());
    }

    @Override
    public List<Person> selectAllPeople() {
        // SQL query to select all people from the database
        // It is a good practice to specify all the columns here (id, name) since
        // we are directly mapping the result set into the Person object as the
        String sql = "SELECT id, name FROM person;";

        // This query passes the SQL and RowMapper as parameter
        // For each RowMapper received, the values of each row is converted to Person object.
        return jdbcTemplate.query(sql, (resultSet, i) ->
                {
                    UUID id = UUID.fromString(resultSet.getString("id"));
                    String name = resultSet.getString("name");
                    return new Person(id, name);
                }
        );
    }

    @Override
    public Optional<Person> selectPersonById(UUID id) {
        // Parameter for WHERE is indicated as ?,
        // hence the actual values to be passed as argument is at Object[]{}
        String sql = " SELECT id, name FROM person WHERE id = ?";

        //TODO: Find out an alternative solution to this replace deprecated method
        Person p = jdbcTemplate.queryForObject(sql, new Object[] {id}, (resultSet, i) ->
                {
                    UUID personId = UUID.fromString(resultSet.getString("id"));
                    String name = resultSet.getString("name");
                    return new Person(personId, name);
                }
        );
        return Optional.ofNullable(p);
    }

    @Override
    public int updatePersonById(UUID id, Person person) {
        String sql = "UPDATE person SET name = ?" +
                "WHERE id = ?";
        // Another variation of JdbcTemplate:update() method
        // You can pass the query with multiple unknown values '?'
        // These values are passed respectively as parameters of update
        return jdbcTemplate.update(sql, person.getName(), id);
    }

    @Override
    public int deletePersonById(UUID id) {
        // Parameter for WHERE is indicated as ?,
        // hence the actual values to be passed as argument is at Object[]{}
        String sql = " DELETE FROM person WHERE id = ?";
        Object[] args = new Object[] {id};

        // Another variation of JdbcTemplate:update() method
        // You can pass the query with 1 value '?' which is the ID
        // ID is passed as part of Object array
        return jdbcTemplate.update(sql, args);
    }
}
